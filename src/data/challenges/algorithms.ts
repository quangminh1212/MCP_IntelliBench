/**
 * @fileoverview Algorithm Design Challenges
 * @module @mcp/intellibench/data/challenges/algorithms
 * @version 1.0.0
 */

import type { Challenge } from '../../shared/types/index.js';
import { ChallengeCategory, Difficulty } from '../../shared/types/index.js';

export const algorithmChallenges: Challenge[] = [
    {
        id: 'algo_001',
        title: 'Find All Anagram Indices',
        description: `Given a string \`s\` and a non-empty string \`p\`, find all the start indices of \`p\`'s anagrams in \`s\`. Return the indices in ascending order.`,
        category: ChallengeCategory.ALGORITHM_DESIGN,
        difficulty: 6,
        difficultyTier: Difficulty.MEDIUM,
        requirements: [
            'Time complexity should be O(n)',
            'Handle large inputs efficiently',
            'Return empty array if no anagrams found',
        ],
        hints: ['Consider using a sliding window approach', 'Use frequency maps'],
        templates: [{
            language: 'typescript',
            template: `function findAnagrams(s: string, p: string): number[] {\n  // Implement your solution\n}`,
            signature: 'function findAnagrams(s, p): number[]',
        }],
        testCases: [
            { id: 'tc1', name: 'Multiple anagrams', input: ['cbaebabacd', 'abc'], expectedOutput: [0, 6], isHidden: false, points: 25 },
            { id: 'tc2', name: 'No anagrams', input: ['hello', 'abc'], expectedOutput: [], isHidden: false, points: 25 },
            { id: 'tc3', name: 'Overlapping', input: ['abab', 'ab'], expectedOutput: [0, 1, 2], isHidden: false, points: 25 },
            { id: 'tc4', name: 'Large input', input: null, expectedOutput: true, isHidden: true, points: 25 },
        ],
        maxScore: 100,
        timeLimit: 300,
        memoryLimit: 256,
        tags: ['algorithm', 'sliding-window', 'string'],
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z',
    },
    {
        id: 'algo_002',
        title: 'Longest Increasing Subsequence',
        description: `Given an integer array \`nums\`, return the length of the longest strictly increasing subsequence. Optimize for O(n log n) time complexity.`,
        category: ChallengeCategory.ALGORITHM_DESIGN,
        difficulty: 7,
        difficultyTier: Difficulty.HARD,
        requirements: [
            'O(n log n) time complexity required',
            'Handle negative numbers',
            'Handle empty and single-element arrays',
        ],
        hints: ['Use binary search', 'Maintain a tail array'],
        templates: [{
            language: 'typescript',
            template: `function lengthOfLIS(nums: number[]): number {\n  // Implement your solution\n}`,
            signature: 'function lengthOfLIS(nums): number',
        }],
        testCases: [
            { id: 'tc1', name: 'Basic case', input: [10, 9, 2, 5, 3, 7, 101, 18], expectedOutput: 4, isHidden: false, points: 25 },
            { id: 'tc2', name: 'All increasing', input: [1, 2, 3, 4, 5], expectedOutput: 5, isHidden: false, points: 25 },
            { id: 'tc3', name: 'All decreasing', input: [5, 4, 3, 2, 1], expectedOutput: 1, isHidden: false, points: 25 },
            { id: 'tc4', name: 'With duplicates', input: [1, 3, 6, 7, 9, 4, 10, 5, 6], expectedOutput: 6, isHidden: true, points: 25 },
        ],
        maxScore: 100,
        timeLimit: 300,
        memoryLimit: 256,
        tags: ['algorithm', 'dynamic-programming', 'binary-search'],
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z',
    },
    {
        id: 'algo_003',
        title: 'Merge K Sorted Lists',
        description: `You are given an array of k linked-lists, each sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.`,
        category: ChallengeCategory.ALGORITHM_DESIGN,
        difficulty: 8,
        difficultyTier: Difficulty.HARD,
        requirements: [
            'Handle empty lists',
            'Efficient merging (O(n log k) where n is total nodes)',
            'Return null for empty input',
        ],
        hints: ['Use a min-heap/priority queue', 'Or use divide and conquer approach'],
        templates: [{
            language: 'typescript',
            template: `interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\nfunction mergeKLists(lists: (ListNode | null)[]): ListNode | null {\n  // Implement your solution\n}`,
            signature: 'function mergeKLists(lists): ListNode | null',
        }],
        testCases: [
            { id: 'tc1', name: 'Three lists', input: [[1, 4, 5], [1, 3, 4], [2, 6]], expectedOutput: [1, 1, 2, 3, 4, 4, 5, 6], isHidden: false, points: 25 },
            { id: 'tc2', name: 'Empty input', input: [], expectedOutput: null, isHidden: false, points: 25 },
            { id: 'tc3', name: 'Single list', input: [[1, 2, 3]], expectedOutput: [1, 2, 3], isHidden: false, points: 25 },
            { id: 'tc4', name: 'Large k', input: null, expectedOutput: true, isHidden: true, points: 25 },
        ],
        maxScore: 100,
        timeLimit: 300,
        memoryLimit: 256,
        tags: ['algorithm', 'heap', 'linked-list', 'divide-conquer'],
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z',
    },
    {
        id: 'algo_004',
        title: 'Word Break Problem',
        description: `Given a string \`s\` and a dictionary of strings \`wordDict\`, return true if \`s\` can be segmented into a space-separated sequence of one or more dictionary words.`,
        category: ChallengeCategory.ALGORITHM_DESIGN,
        difficulty: 6,
        difficultyTier: Difficulty.MEDIUM,
        requirements: [
            'Use dynamic programming',
            'Words can be reused',
            'Handle edge cases (empty string)',
        ],
        templates: [{
            language: 'typescript',
            template: `function wordBreak(s: string, wordDict: string[]): boolean {\n  // Implement your solution\n}`,
            signature: 'function wordBreak(s, wordDict): boolean',
        }],
        testCases: [
            { id: 'tc1', name: 'Can break', input: ['leetcode', ['leet', 'code']], expectedOutput: true, isHidden: false, points: 25 },
            { id: 'tc2', name: 'Cannot break', input: ['catsandog', ['cats', 'dog', 'sand', 'and', 'cat']], expectedOutput: false, isHidden: false, points: 25 },
            { id: 'tc3', name: 'Reuse words', input: ['applepenapple', ['apple', 'pen']], expectedOutput: true, isHidden: false, points: 25 },
            { id: 'tc4', name: 'Long string', input: null, expectedOutput: true, isHidden: true, points: 25 },
        ],
        maxScore: 100,
        timeLimit: 300,
        memoryLimit: 256,
        tags: ['algorithm', 'dynamic-programming', 'string'],
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z',
    },
    {
        id: 'algo_005',
        title: 'Dijkstra Shortest Path',
        description: `Implement Dijkstra's algorithm to find the shortest path from a source node to all other nodes in a weighted graph with non-negative edges.`,
        category: ChallengeCategory.ALGORITHM_DESIGN,
        difficulty: 7,
        difficultyTier: Difficulty.HARD,
        requirements: [
            'Handle disconnected nodes (return Infinity)',
            'Use priority queue for efficiency',
            'Return distances array',
        ],
        templates: [{
            language: 'typescript',
            template: `function dijkstra(graph: number[][], source: number): number[] {\n  // graph[i][j] = weight from i to j (0 means no edge)\n  // Implement your solution\n}`,
            signature: 'function dijkstra(graph, source): number[]',
        }],
        testCases: [
            { id: 'tc1', name: 'Simple graph', input: [[[0, 4, 0, 0, 0], [4, 0, 8, 0, 0], [0, 8, 0, 7, 0], [0, 0, 7, 0, 9], [0, 0, 0, 9, 0]], 0], expectedOutput: [0, 4, 12, 19, 28], isHidden: false, points: 25 },
            { id: 'tc2', name: 'Disconnected', input: [[[0, 1], [1, 0], [0, 0]], 0], expectedOutput: [0, 1, Infinity], isHidden: false, points: 25 },
            { id: 'tc3', name: 'Single node', input: [[[0]], 0], expectedOutput: [0], isHidden: false, points: 25 },
            { id: 'tc4', name: 'Large graph', input: null, expectedOutput: true, isHidden: true, points: 25 },
        ],
        maxScore: 100,
        timeLimit: 300,
        memoryLimit: 256,
        tags: ['algorithm', 'graph', 'shortest-path'],
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z',
    },
    {
        id: 'algo_006',
        title: 'Topological Sort',
        description: `Given a directed acyclic graph (DAG), perform topological sort and return nodes in topological order. Detect if the graph has a cycle.`,
        category: ChallengeCategory.ALGORITHM_DESIGN,
        difficulty: 6,
        difficultyTier: Difficulty.MEDIUM,
        requirements: [
            'Use Kahn\'s algorithm or DFS',
            'Return empty array if cycle exists',
            'Handle disconnected components',
        ],
        templates: [{
            language: 'typescript',
            template: `function topologicalSort(numNodes: number, edges: [number, number][]): number[] {\n  // edges[i] = [from, to]\n  // Implement your solution\n}`,
            signature: 'function topologicalSort(numNodes, edges): number[]',
        }],
        testCases: [
            { id: 'tc1', name: 'Simple DAG', input: [4, [[0, 1], [0, 2], [1, 3], [2, 3]]], expectedOutput: [0, 1, 2, 3], isHidden: false, points: 25 },
            { id: 'tc2', name: 'Has cycle', input: [3, [[0, 1], [1, 2], [2, 0]]], expectedOutput: [], isHidden: false, points: 25 },
            { id: 'tc3', name: 'No edges', input: [3, []], expectedOutput: [0, 1, 2], isHidden: false, points: 25 },
            { id: 'tc4', name: 'Complex DAG', input: null, expectedOutput: true, isHidden: true, points: 25 },
        ],
        maxScore: 100,
        timeLimit: 300,
        memoryLimit: 256,
        tags: ['algorithm', 'graph', 'topological-sort'],
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z',
    },
    {
        id: 'algo_007',
        title: 'Trie Implementation',
        description: `Implement a Trie (Prefix Tree) with the following operations:
- \`insert(word)\`: Insert a word
- \`search(word)\`: Return true if word exists
- \`startsWith(prefix)\`: Return true if any word starts with prefix`,
        category: ChallengeCategory.ALGORITHM_DESIGN,
        difficulty: 6,
        difficultyTier: Difficulty.MEDIUM,
        requirements: [
            'Efficient insert and search O(m) where m is word length',
            'Handle empty strings',
            'Case-sensitive matching',
        ],
        templates: [{
            language: 'typescript',
            template: `class Trie {\n  insert(word: string): void {\n    // Implement\n  }\n  search(word: string): boolean {\n    // Implement\n  }\n  startsWith(prefix: string): boolean {\n    // Implement\n  }\n}`,
            signature: 'class Trie { insert, search, startsWith }',
        }],
        testCases: [
            { id: 'tc1', name: 'Insert and search', input: { ops: ['insert', 'search'], words: ['apple', 'apple'] }, expectedOutput: true, isHidden: false, points: 25 },
            { id: 'tc2', name: 'Not found', input: { ops: ['insert', 'search'], words: ['apple', 'app'] }, expectedOutput: false, isHidden: false, points: 25 },
            { id: 'tc3', name: 'Starts with', input: { ops: ['insert', 'startsWith'], words: ['apple', 'app'] }, expectedOutput: true, isHidden: false, points: 25 },
            { id: 'tc4', name: 'Multiple words', input: null, expectedOutput: true, isHidden: true, points: 25 },
        ],
        maxScore: 100,
        timeLimit: 300,
        memoryLimit: 256,
        tags: ['algorithm', 'trie', 'data-structure'],
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z',
    },
];

export default algorithmChallenges;
